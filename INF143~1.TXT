Tailles couramment utilisés pour les clés publiques et privées générées par l'algorithme RSA:

-1024 bits.
-2048 bits.
-3072 bits.
-4096 bits.
-7680 bits.
-8192 bits.

Algorithme conçu et créé pour le développement du code Python implémentant l'algorithme de chiffrement et de déchiffrement asymétrique RSA, en version finale et fonctionnelle:

string user_reponse="";

Écrire("The present Python program will demonstrate the effectiveness of a right implementation of the RSA assymetric encryption and decryption algorithm. For that purpose, the implementation of that assymetric algorithm RSA uses a certain standard key sizes determined by international organisations around the world, these stardard key sizes are the following ones:\n")

Écrire("-1024 bits.\n")
Écrire("-2048 bits.\n")
Écrire("-3072 bits.\n")
Écrire("-4096 bits.\n")
Écrire("-7680 bits.\n")
Écrire("-8192 bits.\n")

Écrire("The standard key sizes showed above are used by the RSA assymetric encryption and decryption algorithm for the generation and creation of the public and private keys, that are immense and colossal prime numbers genarated randomly. However, for the purpose of the present Python program, these standard key sizes showed above are used also for specifying the size of the message that must be first encryptend and then decrypted by this RSA assymetric encryption and decryption algorithm.")

Écrire("The present Python program, in order to demonstrate the effectiveness of the right implementation of that RSA assymetric encryption and decryption algorithm, needs to know wich  standard key size will be used by the RSA assymetric encryption and decryption algorithm, taking into account that you must chose one of the following stardard key sizes: \n")

Écrire("a: 1024 bits.\n")
Écrire("b: 2048 bits.\n")
Écrire("c: 3072 bits.\n")
Écrire("d: 4096 bits.\n")
Écrire("e: 7680 bits.\n")
Écrire("f: 8192 bits.\n")

Écrire("For that purpose, please specify and chose a standard key size from the list showed out above: ")
Lire(user_reponse)

Si (user_reponse=="a") Alors
{
   Function generate_prime_candidate(length):
      p = RandomBits(length)
      p |= (1 << length - 1) | 1
      return p

    Function generate_prime(length=128):
      desired_bit_length = length * 8
      bit_length = desired_bit_length // 4
    
      p = 4
      While Not is_prime(p):
          p = generate_prime_candidate(bit_length)
      return p

    Function generate_keys():
       p = generate_prime()
       q = generate_prime()
       n = p * q
       phi = (p - 1) * (q - 1)
      
       e = RandomInteger(1, phi)
       Tant que GCD(e, phi) != 1 Faire
          e = RandomInteger(1, phi)
      
       d = ModularInverse(e, phi)
      
    return ((e, n), (d, n))
}     
Sinon Si (user_reponse=="b") Alors
{     
   Function generate_prime_candidate(length):
      p = RandomBits(length)
      p |= (1 << length - 1) | 1
      return p

    Function generate_prime(length=256):
      desired_bit_length = length * 8
      bit_length = desired_bit_length // 4
    
      p = 4
      While Not is_prime(p):
          p = generate_prime_candidate(bit_length)
      return p

    Function generate_keys():
       p = generate_prime()
       q = generate_prime()
       n = p * q
       phi = (p - 1) * (q - 1)
      
       e = RandomInteger(1, phi)
       Tant que GCD(e, phi) != 1 Faire
          e = RandomInteger(1, phi)
      
       d = ModularInverse(e, phi)
      
    return ((e, n), (d, n))   
}
Sinon Si (user_reponse=="c") Alors
{
   Function generate_prime_candidate(length):
      p = RandomBits(length)
      p |= (1 << length - 1) | 1
      return p

    Function generate_prime(length=384):
      desired_bit_length = length * 8
      bit_length = desired_bit_length // 4
    
      p = 4
      While Not is_prime(p):
          p = generate_prime_candidate(bit_length)
      return p

    Function generate_keys():
       p = generate_prime()
       q = generate_prime()
       n = p * q
       phi = (p - 1) * (q - 1)
      
       e = RandomInteger(1, phi)
       Tant que GCD(e, phi) != 1 Faire
          e = RandomInteger(1, phi)
      
       d = ModularInverse(e, phi)
      
    return ((e, n), (d, n))
}
Sinon Si (user_reponse=="d") Alors
{
   Function generate_prime_candidate(length):
      p = RandomBits(length)
      p |= (1 << length - 1) | 1
      return p

    Function generate_prime(length=512):
      desired_bit_length = length * 8
      bit_length = desired_bit_length // 4
    
      p = 4
      While Not is_prime(p):
          p = generate_prime_candidate(bit_length)
      return p

    Function generate_keys():
       p = generate_prime()
       q = generate_prime()
       n = p * q
       phi = (p - 1) * (q - 1)
      
       e = RandomInteger(1, phi)
       Tant que GCD(e, phi) != 1 Faire
          e = RandomInteger(1, phi)
      
       d = ModularInverse(e, phi)
      
    return ((e, n), (d, n))
}
Sinon Si (user_reponse=="e") Alors
{
    Function generate_prime_candidate(length):
      p = RandomBits(length)
      p |= (1 << length - 1) | 1
      return p

    Function generate_prime(length=960):
      desired_bit_length = length * 8
      bit_length = desired_bit_length // 4
    
      p = 4
      While Not is_prime(p):
          p = generate_prime_candidate(bit_length)
      return p

    Function generate_keys():
       p = generate_prime()
       q = generate_prime()
       n = p * q
       phi = (p - 1) * (q - 1)
      
       e = RandomInteger(1, phi)
       Tant que GCD(e, phi) != 1 Faire
          e = RandomInteger(1, phi)
      
       d = ModularInverse(e, phi)
      
    return ((e, n), (d, n))
}
Sinon Si (user_reponse=="f") Alors
{
     Function generate_prime_candidate(length):
      p = RandomBits(length)
      p |= (1 << length - 1) | 1
      return p

    Function generate_prime(length=1024):
      desired_bit_length = length * 8
      bit_length = desired_bit_length // 4
    
      p = 4
      While Not is_prime(p):
          p = generate_prime_candidate(bit_length)
      return p

    Function generate_keys():
       p = generate_prime()
       q = generate_prime()
       n = p * q
       phi = (p - 1) * (q - 1)
      
       e = RandomInteger(1, phi)
       Tant que GCD(e, phi) != 1 Faire
          e = RandomInteger(1, phi)
      
       d = ModularInverse(e, phi)
      
    return ((e, n), (d, n))
}






