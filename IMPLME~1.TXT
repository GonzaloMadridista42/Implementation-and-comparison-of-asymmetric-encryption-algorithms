Gonzalo:
ok chatgpt, maintenant je vais te fournir mon code python en version prototype modifié fonctionnel, qui implémente l'algorithme El-Gamal :  # Python program to illustrate ElGamal encryption

import random
from math import pow

a = random.randint(256, 512)

def gcd(a, b):
    if a < b:
        return gcd(b, a)
    elif a % b == 0:
        return b
    else:
        return gcd(b, a % b)

import random

# Generating large random numbers
def gen_key(q):
    key = random.randint(int(pow(10, 70)), int(q) - 1)
    while gcd(q, key) != 1:
        key = random.randint(int(pow(10, 70)), int(q) - 1)
    return key

# Modular exponentiation
def power(a, b, c):
    x = 1
    y = a

    while b > 0:
        if b % 2 != 0:
            x = (x * y) % c
        y = (y * y) % c
        b = int(b / 2)

    return x % c

# Asymmetric encryption
def encrypt(msg, q, h, g):
 
    en_msg = []
 
    k = gen_key(q)# Private key for sender
    s = power(h, k, q)
    p = power(g, k, q)
     
    for i in range(0, len(msg)):
        en_msg.append(msg[i])
 
    print("g^k used : ", p)
    print("g^ak used : ", s)
    for i in range(0, len(en_msg)):
        en_msg[i] = s * ord(en_msg[i])
 
    return en_msg, p

# Asymmetric decryption
def decrypt(en_msg, p, key, q):
    dr_msg = []
    h = power(p, key, q)
    for i in range(0, len(en_msg)):
        dr_msg.append(chr(int(en_msg[i] / h)))

    return dr_msg

# Driver code
def main():
    message = input("\nEnter the message\n")
    
    print("\nInitial message:")
    print(message)
       
    msg = message
    print("\nOriginal Message :", msg)

    q = random.randint(10**20, 10**90)
    g = random.randint(2, q)

    key = gen_key(q)  # Private key for receiver
    h = power(g, key, q) 
    print("\ng used : ", g)
    print("g^a used : ", h)

    en_msg, p = encrypt(msg, q, h, g)
    dr_msg = decrypt(en_msg, p, key, q)
    dmsg = ''.join(dr_msg)
    print("Decrypted Message :", dmsg)

if __name__ == '__main__':
    main()

ChatGPT:
Parfait, maintenant que vous avez fourni votre

Gonzalo:
Maintenant je veux ajouter, à ce bloc de code python, l'implémentation du critère d'évaluation de la performance de l'algorithme RSA suivant :  Temps d'exécution.

ChatGPT:
Pour mesurer le temps d'exécution de l'algorithme ElGamal, vous pouvez utiliser le module time de Python. Voici comment vous pouvez le faire :

import random
from math import pow
import time

# Votre code ElGamal existant ...

def main():
    message = input("\nEnter the message\n")
    
    print("\nInitial message:")
    print(message)
       
    msg = message
    print("\nOriginal Message :", msg)

    q = random.randint(10**20, 10**90)
    g = random.randint(2, q)

    key = gen_key(q)  # Private key for receiver
    h = power(g, key, q) 
    print("\ng used : ", g)
    print("g^a used : ", h)

    start_time = time.time()  # Mesure le temps de début

    en_msg, p = encrypt(msg, q, h, g)
    dr_msg = decrypt(en_msg, p, key, q)
    dmsg = ''.join(dr_msg)

    end_time = time.time()  # Mesure le temps de fin
    execution_time = end_time - start_time  # Calcul du temps d'exécution
    print("Decrypted Message :", dmsg)
    print("Execution Time:", execution_time, "seconds")

if __name__ == '__main__':
    main()
Cette modification permettra d'afficher le temps d'exécution de l'algorithme ElGamal lors de chaque exécution. Vous pouvez ajuster le code selon vos besoins spécifiques.

Gonzalo:
Ah ok c'est très bon ce que tu m'as fourni, Ok on continue avec avec l'implémentation du critère de l'évaluation de la performanc de mon code python pour El-Gamal suivant :  Utilisation de la mémoire.

ChatGPT:
Pour évaluer l'utilisation de la mémoire dans votre implémentation de l'algorithme ElGamal, vous pouvez utiliser le module resource de Python, qui fournit des fonctionnalités pour obtenir des informations sur l'utilisation des ressources système, telles que la mémoire. Voici comment vous pouvez l'utiliser dans votre code :

import random
from math import pow
import resource

# Votre code ElGamal existant ...

def main():
    message = input("\nEnter the message\n")
    
    print("\nInitial message:")
    print(message)
       
    msg = message
    print("\nOriginal Message :", msg)

    q = random.randint(10**20, 10**90)
    g = random.randint(2, q)

    key = gen_key(q)  # Private key for receiver
    h = power(g, key, q) 
    print("\ng used : ", g)
    print("g^a used : ", h)

    start_memory = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss  # Mesure la mémoire de début

    en_msg, p = encrypt(msg, q, h, g)
    dr_msg = decrypt(en_msg, p, key, q)
    dmsg = ''.join(dr_msg)

    end_memory = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss  # Mesure la mémoire de fin
    memory_usage = end_memory - start_memory  # Calcul de l'utilisation de la mémoire
    print("Decrypted Message :", dmsg)
    print("Memory Usage:", memory_usage, "kilobytes")

if __name__ == '__main__':
    main()
Cette modification permettra d'afficher l'utilisation de la mémoire lors de l'exécution de l'algorithme ElGamal. Vous pouvez ajuster le code selon vos besoins spécifiques et la plate-forme sur laquelle vous exécutez votre code.

Gonzalo:
Ah ok c'est très bon ce que tu m'as fourni, Ok on continue avec avec l'implémentation du critère de l'évaluation de la performanc de mon code python pour El-Gamal suivant :  Taille des clés générées.

ChatGPT:
Pour évaluer la taille des clés générées dans votre implémentation de l'algorithme ElGamal, vous pouvez simplement afficher la taille des clés générées une fois qu'elles sont générées. Voici comment vous pouvez le faire dans votre code :

import random
from math import pow

# Votre code ElGamal existant ...

def main():
    message = input("\nEnter the message\n")
    
    print("\nInitial message:")
    print(message)
       
    msg = message
    print("\nOriginal Message :", msg)

    q = random.randint(10**20, 10**90)
    g = random.randint(2, q)

    key = gen_key(q)  # Private key for receiver
    h = power(g, key, q) 
    print("\ng used : ", g)
    print("g^a used : ", h)

    en_msg, p = encrypt(msg, q, h, g)
    dr_msg = decrypt(en_msg, p, key, q)
    dmsg = ''.join(dr_msg)
    print("Decrypted Message :", dmsg)

    print("\nSize of the private key (in bits):", len(bin(key)) - 2)
    print("Size of the public key (in bits):", len(bin(p)) - 2)

if __name__ == '__main__':
    main()
Cette modification permettra d'afficher la taille des clés privée et publique générées une fois qu'elles sont calculées. Vous pouvez adapter le code selon vos besoins spécifiques et les détails de votre implémentation.

GOnzalo:
Ah ok c'est très bon ce que tu m'as fourni, Ok on continue avec avec l'implémentation du critère de l'évaluation de la performanc de mon code python pour El-Gamal suivant :  Complexité algorithmique.

ChatGPT:
Pour évaluer la complexité algorithmique de votre implémentation de l'algorithme ElGamal, vous pouvez examiner le nombre d'opérations effectuées dans les parties principales de votre code, telles que la génération de clés, le chiffrement et le déchiffrement. Plus précisément, vous pouvez vous concentrer sur le nombre d'opérations effectuées pour des opérations mathématiques telles que la génération de clés, l'exponentiation modulaire, etc.

Voici comment vous pourriez évaluer la complexité algorithmique dans votre code ElGamal :

Génération de clés : La complexité algorithmique de la génération de clés dépend principalement de la façon dont vous générez les nombres premiers aléatoires q et g. Si vous utilisez un algorithme de génération de nombres premiers efficace comme le test de primalité de Miller-Rabin, la complexité serait généralement proche de O(k * log(n)^3), où k est le nombre d'itérations de test de primalité et n est la taille du nombre premier généré.

Chiffrement et déchiffrement : Dans ElGamal, les opérations d'exponentiation modulaire sont utilisées pour chiffrer et déchiffrer les messages. La complexité de l'exponentiation modulaire dépend de l'algorithme utilisé. La méthode de puissance rapide (exponentiation binaire) est généralement utilisée, ce qui a une complexité O(log(e)), où e est l'exposant.

Voici comment vous pourriez inclure l'évaluation de la complexité algorithmique dans votre code ElGamal :

import random
from math import pow
import time

# Votre code ElGamal existant ...

def main():
    message = input("\nEnter the message\n")
    
    print("\nInitial message:")
    print(message)
       
    msg = message
    print("\nOriginal Message :", msg)

    q = random.randint(10**20, 10**90)
    g = random.randint(2, q)

    start_time = time.time()
    key = gen_key(q)  # Private key for receiver
    end_time = time.time()
    print("\nKey generation time: {:.6f} seconds".format(end_time - start_time))

    h = power(g, key, q) 
    print("\ng used : ", g)
    print("g^a used : ", h)

    start_time = time.time()
    en_msg, p = encrypt(msg, q, h, g)
    end_time = time.time()
    print("\nEncryption time: {:.6f} seconds".format(end_time - start_time))

    start_time = time.time()
    dr_msg = decrypt(en_msg, p, key, q)
    end_time = time.time()
    print("\nDecryption time: {:.6f} seconds".format(end_time - start_time))

    dmsg = ''.join(dr_msg)
    print("Decrypted Message :", dmsg)

    print("\nSize of the private key (in bits):", len(bin(key)) - 2)
    print("Size of the public key (in bits):", len(bin(p)) - 2)

if __name__ == '__main__':
    main()
Cela vous permettra de mesurer le temps d'exécution pour la génération de clés, le chiffrement et le déchiffrement, ce qui vous donnera une indication de la complexité algorithmique de votre implémentation ElGamal. Vous pouvez ajuster ces mesures en fonction de vos besoins et des détails spécifiques de votre implémentation.

Gonzalo:
Ah ok c'est très bon ce que tu m'as fourni, Ok on continue avec avec l'implémentation du critère de l'évaluation de la performanc de mon code python pour El-Gamal suivant :  Gestion des grandes quantités de données.

ChatGPT:
Pour évaluer la gestion des grandes quantités de données dans votre implémentation de l'algorithme ElGamal, vous pouvez mesurer les performances de chiffrement et de déchiffrement pour différents volumes de données. Cela vous permettra de voir comment votre implémentation gère efficacement des messages de tailles variables.

Voici comment vous pourriez procéder pour évaluer la gestion des grandes quantités de données dans votre code ElGamal :

Chiffrement avec de grands messages : Mesurez le temps nécessaire pour chiffrer un message de grande taille en comparaison avec un message de taille normale. Vous pouvez augmenter progressivement la taille du message et observer comment le temps de chiffrement évolue.

Déchiffrement avec de grands messages : De la même manière, mesurez le temps nécessaire pour déchiffrer un message de grande taille par rapport à un message de taille normale. Encore une fois, augmentez graduellement la taille du message pour évaluer la performance.

Utilisation de la mémoire : Surveillez l'utilisation de la mémoire pendant le chiffrement et le déchiffrement des messages de grande taille. Vous pouvez utiliser des outils de profilage de la mémoire en Python pour surveiller la quantité de mémoire utilisée par votre programme.

Voici un exemple de code qui vous permettrait de mesurer le temps de chiffrement et de déchiffrement pour différents volumes de données dans votre implémentation ElGamal :

import random
from math import pow
import time

# Votre code ElGamal existant ...

def main():
    message = input("\nEnter the message\n")
    
    print("\nInitial message:")
    print(message)
       
    msg = message
    print("\nOriginal Message :", msg)

    q = random.randint(10**20, 10**90)
    g = random.randint(2, q)

    key = gen_key(q)  # Private key for receiver
    h = power(g, key, q) 
    print("\ng used : ", g)
    print("g^a used : ", h)

    # Chiffrer un message de taille normale
    start_time = time.time()
    en_msg, p = encrypt(msg, q, h, g)
    end_time = time.time()
    print("\nEncryption time for normal message: {:.6f} seconds".format(end_time - start_time))

    # Déchiffrer un message de taille normale
    start_time = time.time()
    dr_msg = decrypt(en_msg, p, key, q)
    end_time = time.time()
    print("\nDecryption time for normal message: {:.6f} seconds".format(end_time - start_time))

    # Chiffrer un message de grande taille (par exemple, en multipliant le message initial)
    large_message = msg * 1000  # Augmenter la taille du message par 1000
    start_time = time.time()
    en_large_msg, p = encrypt(large_message, q, h, g)
    end_time = time.time()
    print("\nEncryption time for large message: {:.6f} seconds".format(end_time - start_time))

    # Déchiffrer un message de grande taille
    start_time = time.time()
    dr_large_msg = decrypt(en_large_msg, p, key, q)
    end_time = time.time()
    print("\nDecryption time for large message: {:.6f} seconds".format(end_time - start_time))

    # Vérification que les messages déchiffrés sont identiques
    assert dr_msg == msg
    assert dr_large_msg == large_message

if __name__ == '__main__':
    main()
Cela vous permettra de comprendre comment votre implémentation ElGamal gère les grandes quantités de données et comment cela affecte les performances de chiffrement et de déchiffrement. Vous pouvez ajuster les tailles des messages selon vos besoins pour obtenir une évaluation précise.

Gonzalo:
Ah ok c'est très bon ce que tu m'as fourni, Ok on continue avec avec l'implémentation du critère de l'évaluation de la performanc de mon code python pour El-Gamal suivant :  Comparaison des tailles de clés.

ChatGPT:
Pour comparer les tailles de clés générées par votre implémentation de l'algorithme ElGamal, vous pouvez mesurer la longueur des clés publiques et privées générées. Cela vous permettra de voir comment la taille des clés varie en fonction des paramètres que vous utilisez.

Voici un exemple de code qui vous permettrait de mesurer les tailles de clés générées par votre implémentation ElGamal :

import random
from math import pow

def gcd(a, b):
    if a < b:
        return gcd(b, a)
    elif a % b == 0:
        return b
    else:
        return gcd(b, a % b)

def gen_key(q):
    key = random.randint(int(pow(10, 70)), int(q) - 1)
    while gcd(q, key) != 1:
        key = random.randint(int(pow(10, 70)), int(q) - 1)
    return key

def key_size(key):
    # Convertir la clé en chaîne de caractères binaire
    binary_key = bin(key)[2:]
    # Calculer la longueur de la clé en bits
    key_length = len(binary_key)
    return key_length

def main():
    # Générer les paramètres du système ElGamal
    q = random.randint(10**20, 10**90)
    g = random.randint(2, q)

    # Générer une clé privée
    private_key = gen_key(q)
    # Calculer la taille de la clé privée
    private_key_length = key_size(private_key)

    # Calculer la clé publique
    public_key = pow(g, private_key, q)
    # Calculer la taille de la clé publique
    public_key_length = key_size(public_key)

    print("Taille de la clé privée: {} bits".format(private_key_length))
    print("Taille de la clé publique: {} bits".format(public_key_length))

if __name__ == '__main__':
    main()
Ce code génère aléatoirement une clé privée et calcule sa taille en bits, ainsi que la taille de la clé publique correspondante. Vous pouvez exécuter ce code pour différentes valeurs de q et observer comment les tailles de clés varient en fonction des paramètres du système ElGamal.

Gonzalo:
Ah ok c'est très bon ce que tu m'as fourni, Ok on continue avec avec l'implémentation du critère de l'évaluation de la performanc de mon code python pour El-Gamal suivant :  Comparaison des temps d'exécution avec différentes tailles de clés.

ChatGPT:
Pour comparer les temps d'exécution de votre implémentation de l'algorithme ElGamal avec différentes tailles de clés, vous pouvez mesurer le temps nécessaire pour générer des clés et pour chiffrer/déchiffrer des messages en utilisant ces clés. Voici un exemple de code qui illustre comment vous pourriez le faire :

import random
import time
from math import pow

def gcd(a, b):
    if a < b:
        return gcd(b, a)
    elif a % b == 0:
        return b
    else:
        return gcd(b, a % b)

def gen_key(q):
    key = random.randint(int(pow(10, 70)), int(q) - 1)
    while gcd(q, key) != 1:
        key = random.randint(int(pow(10, 70)), int(q) - 1)
    return key

def encrypt(msg, q, h, g):
    start_time = time.time()

    en_msg = []

    k = gen_key(q)  # Clé privée pour l'expéditeur
    s = pow(h, k, q)
    p = pow(g, k, q)

    for i in range(0, len(msg)):
        en_msg.append(msg[i])

    print("g^k utilisé : ", p)
    print("g^ak utilisé : ", s)
    for i in range(0, len(en_msg)):
        en_msg[i] = s * ord(en_msg[i])

    end_time = time.time()
    encrypt_time = end_time - start_time
    return en_msg, encrypt_time

def decrypt(en_msg, p, key, q):
    start_time = time.time()

    dr_msg = []
    h = pow(p, key, q)
    for i in range(0, len(en_msg)):
        dr_msg.append(chr(int(en_msg[i] / h)))

    end_time = time.time()
    decrypt_time = end_time - start_time
    return dr_msg, decrypt_time

def main():
    message = input("\nEnter the message\n")

    print("\nInitial message:")
    print(message)

    msg = message
    print("\nMessage original :", msg)

    q = random.randint(10**20, 10**90)
    g = random.randint(2, q)

    key = gen_key(q)  # Clé privée pour le destinataire
    h = pow(g, key, q)
    print("\ng utilisé : ", g)
    print("g^a utilisé : ", h)

    en_msg, encryption_time = encrypt(msg, q, h, g)
    dr_msg, decryption_time = decrypt(en_msg, h, key, q)
    dmsg = ''.join(dr_msg)
    print("Message déchiffré :", dmsg)

    print("\nTemps de chiffrement:", encryption_time, "secondes")
    print("Temps de déchiffrement:", decryption_time, "secondes")

if __name__ == '__main__':
    main()
Ce code mesure le temps nécessaire pour chiffrer et déchiffrer un message en utilisant des clés de taille différente pour le système ElGamal. Vous pouvez exécuter ce code avec différentes valeurs de q pour observer comment les temps d'exécution varient en fonction de la taille des clés.

Gonzalo:
ok mais je ne vis pas dans ton code fourni une implémentatioon de la comparaison des temps d'exécution de génération des clés, encryptage et décryptage du message original clair!

ChatGPT:
Vous avez raison, je m'excuse pour l'omission. Voici une version mise à jour du code qui inclut la mesure du temps nécessaire pour générer les clés, chiffrer et déchiffrer le message :

import random
import time
from math import pow

def gcd(a, b):
    if a < b:
        return gcd(b, a)
    elif a % b == 0:
        return b
    else:
        return gcd(b, a % b)

def gen_key(q):
    start_time = time.time()

    key = random.randint(int(pow(10, 70)), int(q) - 1)
    while gcd(q, key) != 1:
        key = random.randint(int(pow(10, 70)), int(q) - 1)

    end_time = time.time()
    gen_key_time = end_time - start_time
    return key, gen_key_time

def encrypt(msg, q, h, g):
    start_time = time.time()

    en_msg = []

    k = gen_key(q)  # Clé privée pour l'expéditeur
    s = pow(h, k, q)
    p = pow(g, k, q)

    for i in range(0, len(msg)):
        en_msg.append(msg[i])

    print("g^k utilisé : ", p)
    print("g^ak utilisé : ", s)
    for i in range(0, len(en_msg)):
        en_msg[i] = s * ord(en_msg[i])

    end_time = time.time()
    encrypt_time = end_time - start_time
    return en_msg, encrypt_time

def decrypt(en_msg, p, key, q):
    start_time = time.time()

    dr_msg = []
    h = pow(p, key, q)
    for i in range(0, len(en_msg)):
        dr_msg.append(chr(int(en_msg[i] / h)))

    end_time = time.time()
    decrypt_time = end_time - start_time
    return dr_msg, decrypt_time

def main():
    message = input("\nEnter the message\n")

    print("\nInitial message:")
    print(message)

    msg = message
    print("\nMessage original :", msg)

    q = random.randint(10**20, 10**90)
    g = random.randint(2, q)

    key, key_gen_time = gen_key(q)  # Clé privée pour le destinataire
    h = pow(g, key, q)
    print("\ng utilisé : ", g)
    print("g^a utilisé : ", h)

    en_msg, encryption_time = encrypt(msg, q, h, g)
    dr_msg, decryption_time = decrypt(en_msg, h, key, q)
    dmsg = ''.join(dr_msg)
    print("Message déchiffré :", dmsg)

    print("\nTemps de génération de clé:", key_gen_time, "secondes")
    print("Temps de chiffrement:", encryption_time, "secondes")
    print("Temps de déchiffrement:", decryption_time, "secondes")

if __name__ == '__main__':
    main()
Ce code mesure maintenant le temps nécessaire pour générer les clés, chiffrer et déchiffrer le message, et affiche ces informations à la fin de l'exécution. Vous pouvez l'exécuter pour comparer les temps d'exécution avec différentes tailles de clés.

Gonzalo:
ah ca marche maintenant chatgpt. Ok on continue avec avec l'implémentation du critère de l'évaluation de la performanc de mon code python pour El-Gamal suivant :  Comparaison de la taille des messages clairs utilisés, pour bien sécuriser les messages cryptés.

ChatGPT:
Pour évaluer la performance de votre code El-Gamal en termes de la taille des messages clairs utilisés, vous pouvez effectuer une comparaison entre les tailles des messages clairs et les tailles des messages cryptés. Voici comment vous pouvez le faire dans votre code :

Mesurez la taille du message clair avant le chiffrement.
Mesurez la taille du message chiffré après le chiffrement.
Comparez les deux tailles pour évaluer l'impact de la taille du message clair sur la taille du message chiffré.
Voici une version mise à jour de votre code pour inclure cette comparaison :

import random
import time
from math import pow

def gcd(a, b):
    if a < b:
        return gcd(b, a)
    elif a % b == 0:
        return b
    else:
        return gcd(b, a % b)

def gen_key(q):
    start_time = time.time()

    key = random.randint(int(pow(10, 70)), int(q) - 1)
    while gcd(q, key) != 1:
        key = random.randint(int(pow(10, 70)), int(q) - 1)

    end_time = time.time()
    gen_key_time = end_time - start_time
    return key, gen_key_time

def encrypt(msg, q, h, g):
    start_time = time.time()

    en_msg = []

    k = gen_key(q)  # Clé privée pour l'expéditeur
    s = pow(h, k, q)
    p = pow(g, k, q)

    for i in range(0, len(msg)):
        en_msg.append(msg[i])

    print("g^k utilisé : ", p)
    print("g^ak utilisé : ", s)
    for i in range(0, len(en_msg)):
        en_msg[i] = s * ord(en_msg[i])

    end_time = time.time()
    encrypt_time = end_time - start_time
    return en_msg, encrypt_time

def decrypt(en_msg, p, key, q):
    start_time = time.time()

    dr_msg = []
    h = pow(p, key, q)
    for i in range(0, len(en_msg)):
        dr_msg.append(chr(int(en_msg[i] / h)))

    end_time = time.time()
    decrypt_time = end_time - start_time
    return dr_msg, decrypt_time

def main():
    message = input("\nEnter the message\n")

    print("\nInitial message:")
    print(message)

    msg = message
    print("\nMessage original :", msg)

    q = random.randint(10**20, 10**90)
    g = random.randint(2, q)

    key, key_gen_time = gen_key(q)  # Clé privée pour le destinataire
    h = pow(g, key, q)
    print("\ng utilisé : ", g)
    print("g^a utilisé : ", h)

    en_msg, encryption_time = encrypt(msg, q, h, g)
    dr_msg, decryption_time = decrypt(en_msg, h, key, q)
    dmsg = ''.join(dr_msg)
    print("Message déchiffré :", dmsg)

    print("\nTemps de génération de clé:", key_gen_time, "secondes")
    print("Temps de chiffrement:", encryption_time, "secondes")
    print("Temps de déchiffrement:", decryption_time, "secondes")

    # Mesure de la taille des messages
    print("\nTaille du message original:", len(message), "caractères")
    print("Taille du message chiffré:", len(en_msg), "caractères")

if __name__ == '__main__':
    main()
Ce code mesure maintenant la taille du message original avant le chiffrement et la taille du message chiffré après le chiffrement, puis les affiche à la fin de l'exécution. Cela vous permet de comparer les deux tailles et d'évaluer l'impact de la taille du message clair sur la taille du message chiffré.

Gonzalo:
je veux que ton code python travaille avec des bits aussi!

ChatGPT:
Bien sûr, pour que le code travaille avec des bits plutôt qu'avec des caractères, vous pouvez modifier les parties qui traitent les caractères en travaillant directement avec des bits. Voici une version modifiée du code qui utilise des bits :

import random
import time
from math import pow

def gcd(a, b):
    if a < b:
        return gcd(b, a)
    elif a % b == 0:
        return b
    else:
        return gcd(b, a % b)

def gen_key(q):
    start_time = time.time()

    key = random.randint(10**20, q - 1)
    while gcd(q, key) != 1:
        key = random.randint(10**20, q - 1)

    end_time = time.time()
    gen_key_time = end_time - start_time
    return key, gen_key_time

def encrypt(msg, q, h, g):
    start_time = time.time()

    en_msg = []

    k = gen_key(q)  # Clé privée pour l'expéditeur
    s = pow(h, k, q)
    p = pow(g, k, q)

    for bit in msg:
        en_msg.append(bit)

    print("g^k utilisé : ", p)
    print("g^ak utilisé : ", s)
    for i in range(len(en_msg)):
        en_msg[i] = s * en_msg[i] % q

    end_time = time.time()
    encrypt_time = end_time - start_time
    return en_msg, encrypt_time

def decrypt(en_msg, p, key, q):
    start_time = time.time()

    dr_msg = []
    h = pow(p, key, q)
    for i in range(len(en_msg)):
        dr_msg.append(en_msg[i] * pow(h, q-2, q) % q)

    end_time = time.time()
    decrypt_time = end_time - start_time
    return dr_msg, decrypt_time

def main():
    message = input("\nEnter the message\n")
    msg_bits = [int(bit) for bit in message]

    print("\nInitial message (bits):")
    print(msg_bits)

    q = random.randint(10**20, 10**90)
    g = random.randint(2, q)

    key, key_gen_time = gen_key(q)  # Clé privée pour le destinataire
    h = pow(g, key, q)
    print("\ng utilisé : ", g)
    print("g^a utilisé : ", h)

    en_msg, encryption_time = encrypt(msg_bits, q, h, g)
    dr_msg, decryption_time = decrypt(en_msg, h, key, q)
    print("Message déchiffré (bits) :", dr_msg)

    print("\nTemps de génération de clé:", key_gen_time, "secondes")
    print("Temps de chiffrement:", encryption_time, "secondes")
    print("Temps de déchiffrement:", decryption_time, "secondes")

    # Mesure de la taille des messages
    print("\nTaille du message original (bits):", len(message), "bits")
    print("Taille du message chiffré (bits):", len(en_msg), "bits")

if __name__ == '__main__':
    main()
Dans ce code, le message d'entrée est converti en une liste de bits (0 ou 1). L'opération de chiffrement est effectuée bit par bit, et les opérations de déchiffrement sont également effectuées bit par bit. Cela permet de travailler directement avec des bits au lieu de caractères.




